package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"gnomad-browser/gnomad-go-api/internal/data/queries"
	"gnomad-browser/gnomad-go-api/internal/elastic"
	"gnomad-browser/gnomad-go-api/internal/graph/model"
	"strings"
)

// Pli is the resolver for the pli field.
func (r *exacConstraintResolver) Pli(ctx context.Context, obj *model.ExacConstraint) (*float64, error) {
	return obj.Pli, nil
}

// PLi is the resolver for the pLI field.
func (r *exacConstraintResolver) PLi(ctx context.Context, obj *model.ExacConstraint) (float64, error) {
	// This is a deprecated field - return pli value or 0
	if obj.Pli != nil {
		return *obj.Pli, nil
	}
	return 0, nil
}

// Variants is the resolver for the variants field.
func (r *geneResolver) Variants(ctx context.Context, obj *model.Gene, dataset model.DatasetID) ([]*model.Variant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset to string
	datasetStr := string(dataset)

	// Use efficient gene-based variant fetching instead of looping through exons
	variants, err := queries.FetchVariantsByGene(ctx, esClient, obj.GeneID, obj.Chrom, obj.Exons, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching variants for gene: %w", err)
	}

	return variants, nil
}

// StructuralVariants is the resolver for the structural_variants field.
func (r *geneResolver) StructuralVariants(ctx context.Context, obj *model.Gene, dataset model.StructuralVariantDatasetID) ([]*model.StructuralVariant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Fetch structural variants for this gene
	return queries.FetchStructuralVariantsByGene(ctx, esClient, obj.Symbol, dataset)
}

// MitochondrialVariants is the resolver for the mitochondrial_variants field.
func (r *geneResolver) MitochondrialVariants(ctx context.Context, obj *model.Gene, dataset model.DatasetID) ([]*model.MitochondrialVariant, error) {
	// Mitochondrial variants are only available for mitochondrial genes (chromosome M)
	if obj.Chrom != "M" {
		return nil, fmt.Errorf("mitochondrial variants are only available for mitochondrial genes")
	}

	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	var datasetStr string
	switch dataset {
	case model.DatasetIDGnomadR4:
		datasetStr = "gnomad_r4"
	default:
		return nil, fmt.Errorf("mitochondrial variants are not available for dataset: %v", dataset)
	}

	// Fetch mitochondrial variants for this gene
	variants, err := queries.FetchMitochondrialVariantsByGene(ctx, esClient, obj.GeneID, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch mitochondrial variants for gene %s: %w", obj.GeneID, err)
	}

	return variants, nil
}

// ClinvarVariants is the resolver for the clinvar_variants field.
func (r *geneResolver) ClinvarVariants(ctx context.Context, obj *model.Gene) ([]*model.ClinVarVariant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome enum to string
	var refGenomeStr string
	switch obj.ReferenceGenome {
	case model.ReferenceGenomeIDGRCh37:
		refGenomeStr = "GRCh37"
	case model.ReferenceGenomeIDGRCh38:
		refGenomeStr = "GRCh38"
	default:
		return nil, fmt.Errorf("unsupported reference genome: %v", obj.ReferenceGenome)
	}

	// Fetch ClinVar variants for gene
	return queries.FetchClinVarVariantsByGene(ctx, esClient, obj.GeneID, refGenomeStr)
}

// Coverage is the resolver for the coverage field.
func (r *geneResolver) Coverage(ctx context.Context, obj *model.Gene, dataset *model.DatasetID) (*model.FeatureCoverage, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Use provided dataset or default to gnomad_r4
	datasetStr := "gnomad_r4"
	if dataset != nil {
		datasetStr = string(*dataset)
	}

	// Get gene exons to define coverage regions
	regions := make([]queries.CoverageRegion, len(obj.Exons))
	for i, exon := range obj.Exons {
		regions[i] = queries.CoverageRegion{
			Start: exon.Start,
			Stop:  exon.Stop,
		}
	}

	// Fetch coverage for gene exons
	coverage, err := queries.FetchFeatureCoverage(ctx, esClient, obj.GeneID, datasetStr, regions, obj.Chrom)
	if err != nil {
		return nil, err
	}

	// Ensure coverage is not nil and has the required structure
	if coverage == nil {
		coverage = &model.FeatureCoverage{
			Exome:  []*model.CoverageBin{},
			Genome: []*model.CoverageBin{},
		}
	}

	// Ensure arrays are not nil
	if coverage.Exome == nil {
		coverage.Exome = []*model.CoverageBin{}
	}
	if coverage.Genome == nil {
		coverage.Genome = []*model.CoverageBin{}
	}

	return coverage, nil
}

// MitochondrialCoverage is the resolver for the mitochondrial_coverage field.
func (r *geneResolver) MitochondrialCoverage(ctx context.Context, obj *model.Gene, dataset model.DatasetID) ([]*model.MitochondrialCoverageBin, error) {
	// TODO: Implement mitochondrial coverage
	// For now, return empty array to avoid panic
	return []*model.MitochondrialCoverageBin{}, nil
}

// CnvTrackCallableCoverage is the resolver for the cnv_track_callable_coverage field.
func (r *geneResolver) CnvTrackCallableCoverage(ctx context.Context, obj *model.Gene, dataset model.CopyNumberVariantDatasetID) ([]*model.CNVTrackCallableCoverageBin, error) {
	// TODO: Implement CNV track callable coverage
	// For now, return empty array to avoid panic
	return []*model.CNVTrackCallableCoverageBin{}, nil
}

// ShortTandemRepeats is the resolver for the short_tandem_repeats field.
func (r *geneResolver) ShortTandemRepeats(ctx context.Context, obj *model.Gene, dataset model.DatasetID) ([]*model.ShortTandemRepeat, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	var datasetStr string
	switch dataset {
	case model.DatasetIDGnomadR3:
		datasetStr = "gnomad_r3"
	case model.DatasetIDGnomadR4:
		datasetStr = "gnomad_r4"
	default:
		return nil, fmt.Errorf("short tandem repeats are not available for dataset: %v", dataset)
	}

	// Fetch short tandem repeats for this gene
	strs, err := queries.FetchShortTandemRepeatsByGene(ctx, esClient, obj.GeneID, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching short tandem repeats for gene %s: %w", obj.GeneID, err)
	}

	return strs, nil
}

// HeterozygousVariantCooccurrenceCounts is the resolver for the heterozygous_variant_cooccurrence_counts field.
func (r *geneResolver) HeterozygousVariantCooccurrenceCounts(ctx context.Context, obj *model.Gene) ([]*model.HeterozygousVariantCooccurrenceCounts, error) {
	// TODO: Implement variant cooccurrence counts
	// For now, return empty array to avoid panic
	return []*model.HeterozygousVariantCooccurrenceCounts{}, nil
}

// HomozygousVariantCooccurrenceCounts is the resolver for the homozygous_variant_cooccurrence_counts field.
func (r *geneResolver) HomozygousVariantCooccurrenceCounts(ctx context.Context, obj *model.Gene) ([]*model.HomozygousVariantCooccurrenceCounts, error) {
	// TODO: Implement variant cooccurrence counts
	// For now, return empty array to avoid panic
	return []*model.HomozygousVariantCooccurrenceCounts{}, nil
}

// CopyNumberVariants is the resolver for the copy_number_variants field.
func (r *geneResolver) CopyNumberVariants(ctx context.Context, obj *model.Gene, dataset model.CopyNumberVariantDatasetID) ([]*model.CopyNumberVariant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	var datasetStr string
	switch dataset {
	case model.CopyNumberVariantDatasetIDGnomadCnvR4:
		datasetStr = "gnomad_cnv_r4"
	default:
		return nil, fmt.Errorf("copy number variants are not available for dataset: %v", dataset)
	}

	// Fetch copy number variants for this gene
	return queries.FetchCopyNumberVariantsByGene(ctx, esClient, obj.Symbol, datasetStr)
}

// GtexTissueExpression is the resolver for the gtex_tissue_expression field.
func (r *geneTranscriptResolver) GtexTissueExpression(ctx context.Context, obj *model.GeneTranscript) ([]*model.GtexTissue, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome enum to string
	var refGenomeStr string
	switch obj.ReferenceGenome {
	case model.ReferenceGenomeIDGRCh37:
		refGenomeStr = "GRCh37"
	case model.ReferenceGenomeIDGRCh38:
		refGenomeStr = "GRCh38"
	default:
		return nil, fmt.Errorf("unsupported reference genome: %v", obj.ReferenceGenome)
	}

	// Fetch GTEx tissue expression for this transcript
	return queries.FetchGtexTissueExpression(ctx, esClient, obj.TranscriptID, refGenomeStr)
}

// Pli is the resolver for the pli field.
func (r *gnomadConstraintResolver) Pli(ctx context.Context, obj *model.GnomadConstraint) (*float64, error) {
	return obj.Pli, nil
}

// PLi is the resolver for the pLI field.
func (r *gnomadConstraintResolver) PLi(ctx context.Context, obj *model.GnomadConstraint) (*float64, error) {
	// This is a deprecated field - return the same as pli
	return obj.Pli, nil
}

// Meta is the resolver for the meta field.
func (r *queryResolver) Meta(ctx context.Context) (*model.Meta, error) {
	// For now, return a hardcoded ClinVar release date
	// TODO: Fetch this from a configuration file or database
	clinvarDate := "2025-04-29"
	return &model.Meta{
		ClinvarReleaseDate: &clinvarDate,
	}, nil
}

// Variant is the resolver for the variant field.
func (r *queryResolver) Variant(ctx context.Context, variantID *string, rsid *string, vrsID *string, dataset model.DatasetID) (*model.VariantDetails, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Validate that exactly one ID is provided
	idCount := 0
	if variantID != nil {
		idCount++
	}
	if rsid != nil {
		idCount++
	}
	if vrsID != nil {
		idCount++
	}

	if idCount != 1 {
		return nil, fmt.Errorf("exactly one of variantId, rsid, or vrsId must be provided")
	}

	// Dispatch to appropriate fetcher
	datasetStr := string(dataset)

	if variantID != nil {
		normalizedID := queries.NormalizeVariantID(*variantID)
		return queries.FetchVariantByID(ctx, esClient, datasetStr, normalizedID)
	}

	if rsid != nil {
		normalizedRSID := strings.ToLower(*rsid)
		return queries.FetchVariantByRSID(ctx, esClient, datasetStr, normalizedRSID)
	}

	if vrsID != nil {
		return queries.FetchVariantByVRSID(ctx, esClient, datasetStr, *vrsID)
	}

	return nil, fmt.Errorf("no variant ID provided")
}

// StructuralVariant is the resolver for the structural_variant field.
func (r *queryResolver) StructuralVariant(ctx context.Context, variantID string, dataset model.StructuralVariantDatasetID) (*model.StructuralVariantDetails, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Fetch the structural variant
	variant, err := queries.FetchStructuralVariant(ctx, esClient, variantID, dataset)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch structural variant: %w", err)
	}

	if variant == nil {
		return nil, fmt.Errorf("structural variant not found: %s", variantID)
	}

	return variant, nil
}

// Gene is the resolver for the gene field.
func (r *queryResolver) Gene(ctx context.Context, geneID *string, geneSymbol *string, referenceGenome model.ReferenceGenomeID) (*model.Gene, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Check that at least one identifier is provided
	if geneID == nil && geneSymbol == nil {
		return nil, fmt.Errorf("one of 'gene_id' or 'gene_symbol' is required")
	}

	// Convert reference genome ID to string
	refGenomeStr := string(referenceGenome)

	// Fetch by gene ID if provided
	if geneID != nil {
		gene, err := queries.FetchGeneByID(ctx, esClient, *geneID, refGenomeStr)
		if err != nil {
			return nil, err
		}
		if gene == nil {
			return nil, fmt.Errorf("gene not found")
		}
		return gene, nil
	}

	// Otherwise, fetch by gene symbol
	gene, err := queries.FetchGeneBySymbol(ctx, esClient, *geneSymbol, refGenomeStr)
	if err != nil {
		return nil, err
	}
	if gene == nil {
		return nil, fmt.Errorf("gene not found")
	}
	return gene, nil
}

// Transcript is the resolver for the transcript field.
func (r *queryResolver) Transcript(ctx context.Context, transcriptID string, referenceGenome model.ReferenceGenomeID) (*model.Transcript, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome ID to string
	refGenomeStr := string(referenceGenome)

	// Fetch the transcript
	transcript, err := queries.FetchTranscript(ctx, esClient, transcriptID, refGenomeStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching transcript: %w", err)
	}

	if transcript == nil {
		return nil, fmt.Errorf("transcript not found")
	}

	return transcript, nil
}

// Region is the resolver for the region field.
func (r *queryResolver) Region(ctx context.Context, chrom string, start int, stop int, referenceGenome model.ReferenceGenomeID) (*model.Region, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome ID to string
	refGenomeStr := string(referenceGenome)

	// Fetch the region
	region, err := queries.FetchRegion(ctx, esClient, chrom, start, stop, refGenomeStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching region: %w", err)
	}

	return region, nil
}

// GeneSearch is the resolver for the gene_search field.
func (r *queryResolver) GeneSearch(ctx context.Context, query string, referenceGenome model.ReferenceGenomeID) ([]*model.GeneSearchResult, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome ID to string
	refGenomeStr := string(referenceGenome)

	// Fetch genes matching the query
	results, err := queries.FetchGenesMatchingText(ctx, esClient, query, refGenomeStr)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// VariantSearch is the resolver for the variant_search field.
func (r *queryResolver) VariantSearch(ctx context.Context, query string, dataset model.DatasetID) ([]*model.VariantSearchResult, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset ID to string
	datasetStr := string(dataset)

	// Fetch matching variants
	results, err := queries.FetchMatchingVariants(ctx, esClient, query, datasetStr)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// VariantCooccurrence is the resolver for the variant_cooccurrence field.
func (r *queryResolver) VariantCooccurrence(ctx context.Context, variants []string, dataset model.DatasetID) (*model.VariantCooccurrence, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Call the variant co-occurrence query function
	return queries.FetchVariantCooccurrence(ctx, esClient, variants, string(dataset))
}

// Liftover is the resolver for the liftover field.
func (r *queryResolver) Liftover(ctx context.Context, sourceVariantID *string, liftoverVariantID *string, referenceGenome model.ReferenceGenomeID) ([]*model.LiftoverResult, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome enum to string
	var refGenomeStr string
	switch referenceGenome {
	case model.ReferenceGenomeIDGRCh37:
		refGenomeStr = "GRCh37"
	case model.ReferenceGenomeIDGRCh38:
		refGenomeStr = "GRCh38"
	default:
		return nil, fmt.Errorf("unsupported reference genome: %v", referenceGenome)
	}

	// Fetch liftover data
	return queries.FetchLiftover(ctx, esClient, sourceVariantID, liftoverVariantID, refGenomeStr)
}

// CopyNumberVariant is the resolver for the copy_number_variant field.
func (r *queryResolver) CopyNumberVariant(ctx context.Context, variantID string, dataset model.CopyNumberVariantDatasetID) (*model.CopyNumberVariantDetails, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset ID to string
	datasetStr := string(dataset)

	// Fetch CNV details
	cnvDetails, err := queries.FetchCopyNumberVariant(ctx, esClient, variantID, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching copy number variant: %w", err)
	}

	if cnvDetails == nil {
		return nil, fmt.Errorf("Variant not found")
	}

	return cnvDetails, nil
}

// ClinvarVariant is the resolver for the clinvar_variant field.
func (r *queryResolver) ClinvarVariant(ctx context.Context, variantID string, referenceGenome model.ReferenceGenomeID) (*model.ClinVarVariantDetails, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome enum to string
	var refGenomeStr string
	switch referenceGenome {
	case model.ReferenceGenomeIDGRCh37:
		refGenomeStr = "GRCh37"
	case model.ReferenceGenomeIDGRCh38:
		refGenomeStr = "GRCh38"
	default:
		return nil, fmt.Errorf("unsupported reference genome: %v", referenceGenome)
	}

	// Fetch ClinVar variant
	return queries.FetchClinVarVariant(ctx, esClient, variantID, refGenomeStr)
}

// ShortTandemRepeat is the resolver for the short_tandem_repeat field.
func (r *queryResolver) ShortTandemRepeat(ctx context.Context, id string, dataset model.DatasetID) (*model.ShortTandemRepeatDetails, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset ID to string
	datasetStr := string(dataset)

	// Fetch STR details
	strDetails, err := queries.FetchShortTandemRepeat(ctx, esClient, id, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching short tandem repeat: %w", err)
	}

	return strDetails, nil
}

// ShortTandemRepeats is the resolver for the short_tandem_repeats field.
func (r *queryResolver) ShortTandemRepeats(ctx context.Context, dataset model.DatasetID) ([]*model.ShortTandemRepeat, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset ID to string
	datasetStr := string(dataset)

	// Fetch all STRs
	strs, err := queries.FetchShortTandemRepeats(ctx, esClient, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching short tandem repeats: %w", err)
	}

	return strs, nil
}

// MultiNucleotideVariant is the resolver for the multi_nucleotide_variant field.
func (r *queryResolver) MultiNucleotideVariant(ctx context.Context, variantID string, dataset model.DatasetID) (*model.MultiNucleotideVariantDetails, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	var datasetStr string
	switch dataset {
	case model.DatasetIDGnomadR21:
		datasetStr = "gnomad_r2_1"
	default:
		return nil, fmt.Errorf("multi-nucleotide variants are only available for gnomAD r2.1")
	}

	// Fetch multi-nucleotide variant
	return queries.FetchMultiNucleotideVariant(ctx, esClient, variantID, datasetStr)
}

// MitochondrialVariant is the resolver for the mitochondrial_variant field.
func (r *queryResolver) MitochondrialVariant(ctx context.Context, variantID string, dataset model.DatasetID) (*model.MitochondrialVariantDetails, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	var datasetStr string
	switch dataset {
	case model.DatasetIDGnomadR4:
		datasetStr = "gnomad_r4"
	default:
		return nil, fmt.Errorf("mitochondrial variants are not available for dataset: %v", dataset)
	}

	// Fetch mitochondrial variant
	variant, err := queries.FetchMitochondrialVariant(ctx, esClient, variantID, datasetStr)
	if err != nil {
		// Check if it's a not found error
		if _, ok := err.(*queries.VariantNotFoundError); ok {
			return nil, fmt.Errorf("mitochondrial variant not found: %s", variantID)
		}
		return nil, fmt.Errorf("failed to fetch mitochondrial variant %s: %w", variantID, err)
	}

	return variant, nil
}

// Genes is the resolver for the genes field.
func (r *regionResolver) Genes(ctx context.Context, obj *model.Region) ([]*model.RegionGene, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome to string
	var refGenomeStr string
	switch obj.ReferenceGenome {
	case model.ReferenceGenomeIDGRCh37:
		refGenomeStr = "GRCh37"
	case model.ReferenceGenomeIDGRCh38:
		refGenomeStr = "GRCh38"
	default:
		return nil, fmt.Errorf("unsupported reference genome: %v", obj.ReferenceGenome)
	}

	// Fetch genes in the region
	return queries.FetchGenesInRegion(ctx, esClient, obj.Chrom, obj.Start, obj.Stop, refGenomeStr)
}

// NonCodingConstraints is the resolver for the non_coding_constraints field.
func (r *regionResolver) NonCodingConstraints(ctx context.Context, obj *model.Region) ([]*model.NonCodingConstraintRegion, error) {
	// TODO: Implement non-coding constraints
	// For now, return empty array to avoid panic
	return []*model.NonCodingConstraintRegion{}, nil
}

// Variants is the resolver for the variants field.
func (r *regionResolver) Variants(ctx context.Context, obj *model.Region, dataset model.DatasetID) ([]*model.Variant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset to string
	datasetStr := string(dataset)

	// Fetch variants in the region
	return queries.FetchVariantsInRegion(ctx, esClient, obj.Chrom, obj.Start, obj.Stop, datasetStr)
}

// StructuralVariants is the resolver for the structural_variants field.
func (r *regionResolver) StructuralVariants(ctx context.Context, obj *model.Region, dataset model.StructuralVariantDatasetID) ([]*model.StructuralVariant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Fetch structural variants for this region
	return queries.FetchStructuralVariantsByRegion(ctx, esClient, obj.Chrom, obj.Start, obj.Stop, dataset)
}

// MitochondrialVariants is the resolver for the mitochondrial_variants field.
func (r *regionResolver) MitochondrialVariants(ctx context.Context, obj *model.Region, dataset model.DatasetID) ([]*model.MitochondrialVariant, error) {
	// Mitochondrial variants are only available for mitochondrial regions (chromosome M)
	if obj.Chrom != "M" {
		return nil, fmt.Errorf("mitochondrial variants are only available for mitochondrial regions")
	}

	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	var datasetStr string
	switch dataset {
	case model.DatasetIDGnomadR4:
		datasetStr = "gnomad_r4"
	default:
		return nil, fmt.Errorf("mitochondrial variants are not available for dataset: %v", dataset)
	}

	// Fetch mitochondrial variants in this region
	variants, err := queries.FetchMitochondrialVariantsByRegion(ctx, esClient, obj.Chrom, obj.Start, obj.Stop, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch mitochondrial variants for region %s:%d-%d: %w", obj.Chrom, obj.Start, obj.Stop, err)
	}

	return variants, nil
}

// CopyNumberVariants is the resolver for the copy_number_variants field.
func (r *regionResolver) CopyNumberVariants(ctx context.Context, obj *model.Region, dataset model.CopyNumberVariantDatasetID) ([]*model.CopyNumberVariant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	var datasetStr string
	switch dataset {
	case model.CopyNumberVariantDatasetIDGnomadCnvR4:
		datasetStr = "gnomad_cnv_r4"
	default:
		return nil, fmt.Errorf("copy number variants are not available for dataset: %v", dataset)
	}

	// Calculate xpos values
	xstart := float64(queries.XPosition(obj.Chrom, obj.Start))
	xstop := float64(queries.XPosition(obj.Chrom, obj.Stop))

	// Fetch copy number variants for this region
	return queries.FetchCopyNumberVariantsByRegion(ctx, esClient, obj.Chrom, obj.Start, obj.Stop, xstart, xstop, datasetStr)
}

// ClinvarVariants is the resolver for the clinvar_variants field.
func (r *regionResolver) ClinvarVariants(ctx context.Context, obj *model.Region) ([]*model.ClinVarVariant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome enum to string
	var refGenomeStr string
	switch obj.ReferenceGenome {
	case model.ReferenceGenomeIDGRCh37:
		refGenomeStr = "GRCh37"
	case model.ReferenceGenomeIDGRCh38:
		refGenomeStr = "GRCh38"
	default:
		return nil, fmt.Errorf("unsupported reference genome: %v", obj.ReferenceGenome)
	}

	// Fetch ClinVar variants for region
	return queries.FetchClinVarVariantsByRegion(ctx, esClient, obj.Chrom, obj.Start, obj.Stop, refGenomeStr)
}

// Coverage is the resolver for the coverage field.
func (r *regionResolver) Coverage(ctx context.Context, obj *model.Region, dataset model.DatasetID) (*model.RegionCoverage, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	datasetStr := string(dataset)

	// Fetch coverage for region
	return queries.FetchRegionCoverage(ctx, esClient, obj.Chrom, obj.Start, obj.Stop, datasetStr)
}

// MitochondrialCoverage is the resolver for the mitochondrial_coverage field.
func (r *regionResolver) MitochondrialCoverage(ctx context.Context, obj *model.Region, dataset model.DatasetID) ([]*model.MitochondrialCoverageBin, error) {
	// TODO: Implement mitochondrial coverage for region
	// For now, return empty array to avoid panic
	return []*model.MitochondrialCoverageBin{}, nil
}

// ShortTandemRepeats is the resolver for the short_tandem_repeats field.
func (r *regionResolver) ShortTandemRepeats(ctx context.Context, obj *model.Region, dataset model.DatasetID) ([]*model.ShortTandemRepeat, error) {
	// TODO: Implement STR fetching for region
	// For now, return empty array to avoid panic
	return []*model.ShortTandemRepeat{}, nil
}

// Gene is the resolver for the gene field.
func (r *transcriptResolver) Gene(ctx context.Context, obj *model.Transcript) (*model.TranscriptGene, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome enum to string
	var refGenomeStr string
	switch obj.ReferenceGenome {
	case model.ReferenceGenomeIDGRCh37:
		refGenomeStr = "GRCh37"
	case model.ReferenceGenomeIDGRCh38:
		refGenomeStr = "GRCh38"
	default:
		return nil, fmt.Errorf("unsupported reference genome: %v", obj.ReferenceGenome)
	}

	// Fetch the gene for this transcript
	gene, err := queries.FetchGeneByID(ctx, esClient, obj.GeneID, refGenomeStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching gene for transcript: %w", err)
	}

	// Convert Gene to TranscriptGene
	if gene == nil {
		// Return empty TranscriptGene instead of nil to satisfy non-nullable schema
		return &model.TranscriptGene{
			ReferenceGenome: obj.ReferenceGenome,
			GeneID:          obj.GeneID,
			GeneVersion:     "",
			Symbol:          "",
			Chrom:           obj.Chrom,
			Start:           obj.Start,
			Stop:            obj.Stop,
		}, nil
	}

	// Map Gene fields to TranscriptGene fields
	return &model.TranscriptGene{
		ReferenceGenome: gene.ReferenceGenome,
		GeneID:          gene.GeneID,
		GeneVersion:     gene.GeneVersion,
		Symbol:          gene.Symbol,
		HgncID:          gene.HgncID,
		NcbiID:          gene.NcbiID,
		OmimID:          gene.OmimID,
		Name:            gene.Name,
		Chrom:           gene.Chrom,
		Start:           gene.Start,
		Stop:            gene.Stop,
	}, nil
}

// GtexTissueExpression is the resolver for the gtex_tissue_expression field.
func (r *transcriptResolver) GtexTissueExpression(ctx context.Context, obj *model.Transcript) ([]*model.GtexTissue, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert reference genome enum to string
	var refGenomeStr string
	switch obj.ReferenceGenome {
	case model.ReferenceGenomeIDGRCh37:
		refGenomeStr = "GRCh37"
	case model.ReferenceGenomeIDGRCh38:
		refGenomeStr = "GRCh38"
	default:
		return nil, fmt.Errorf("unsupported reference genome: %v", obj.ReferenceGenome)
	}

	// Fetch GTEx tissue expression for this transcript
	return queries.FetchGtexTissueExpression(ctx, esClient, obj.TranscriptID, refGenomeStr)
}

// Variants is the resolver for the variants field.
func (r *transcriptResolver) Variants(ctx context.Context, obj *model.Transcript, dataset model.DatasetID) ([]*model.Variant, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset to string
	datasetStr := string(dataset)

	// Use efficient gene-based variant fetching (transcript GeneID matches gene_id field)
	variants, err := queries.FetchVariantsByGene(ctx, esClient, obj.GeneID, obj.Chrom, obj.Exons, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("error fetching variants for transcript: %w", err)
	}

	return variants, nil
}

// MitochondrialVariants is the resolver for the mitochondrial_variants field.
func (r *transcriptResolver) MitochondrialVariants(ctx context.Context, obj *model.Transcript, dataset model.DatasetID) ([]*model.MitochondrialVariant, error) {
	// Mitochondrial variants are only available for mitochondrial transcripts (chromosome M)
	if obj.Chrom != "M" {
		return nil, fmt.Errorf("mitochondrial variants are only available for mitochondrial transcripts")
	}
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Convert dataset enum to string
	var datasetStr string
	switch dataset {
	case model.DatasetIDGnomadR4:
		datasetStr = "gnomad_r4"
	default:
		return nil, fmt.Errorf("mitochondrial variants are not available for dataset: %v", dataset)
	}

	// For mitochondrial genes, transcript and gene queries are equivalent.
	// Fetch mitochondrial variants for the transcript's gene
	variants, err := queries.FetchMitochondrialVariantsByTranscript(ctx, esClient, obj.TranscriptID, obj.GeneID, datasetStr)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch mitochondrial variants for transcript %s: %w", obj.TranscriptID, err)
	}

	return variants, nil
}

// ClinvarVariants is the resolver for the clinvar_variants field.
func (r *transcriptResolver) ClinvarVariants(ctx context.Context, obj *model.Transcript) ([]*model.ClinVarVariant, error) {
	// TODO: Implement ClinVar variant fetching for transcript
	// For now, return empty array to avoid panic
	return []*model.ClinVarVariant{}, nil
}

// Coverage is the resolver for the coverage field.
func (r *transcriptResolver) Coverage(ctx context.Context, obj *model.Transcript, dataset *model.DatasetID) (*model.FeatureCoverage, error) {
	// Get Elasticsearch client from context
	esClient := elastic.FromContext(ctx)
	if esClient == nil {
		return nil, fmt.Errorf("elasticsearch client not found in context")
	}

	// Use provided dataset or default to gnomad_r4
	datasetStr := "gnomad_r4"
	if dataset != nil {
		datasetStr = string(*dataset)
	}

	// Get transcript exons to define coverage regions
	regions := make([]queries.CoverageRegion, len(obj.Exons))
	for i, exon := range obj.Exons {
		regions[i] = queries.CoverageRegion{
			Start: exon.Start,
			Stop:  exon.Stop,
		}
	}

	// Fetch coverage for transcript exons
	return queries.FetchFeatureCoverage(ctx, esClient, obj.TranscriptID, datasetStr, regions, obj.Chrom)
}

// MitochondrialCoverage is the resolver for the mitochondrial_coverage field.
func (r *transcriptResolver) MitochondrialCoverage(ctx context.Context, obj *model.Transcript, dataset model.DatasetID) ([]*model.MitochondrialCoverageBin, error) {
	// TODO: Implement mitochondrial coverage for transcript
	// For now, return empty array to avoid panic
	return []*model.MitochondrialCoverageBin{}, nil
}

// ExacConstraint returns ExacConstraintResolver implementation.
func (r *Resolver) ExacConstraint() ExacConstraintResolver { return &exacConstraintResolver{r} }

// Gene returns GeneResolver implementation.
func (r *Resolver) Gene() GeneResolver { return &geneResolver{r} }

// GeneTranscript returns GeneTranscriptResolver implementation.
func (r *Resolver) GeneTranscript() GeneTranscriptResolver { return &geneTranscriptResolver{r} }

// GnomadConstraint returns GnomadConstraintResolver implementation.
func (r *Resolver) GnomadConstraint() GnomadConstraintResolver { return &gnomadConstraintResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Region returns RegionResolver implementation.
func (r *Resolver) Region() RegionResolver { return &regionResolver{r} }

// Transcript returns TranscriptResolver implementation.
func (r *Resolver) Transcript() TranscriptResolver { return &transcriptResolver{r} }

type exacConstraintResolver struct{ *Resolver }
type geneResolver struct{ *Resolver }
type geneTranscriptResolver struct{ *Resolver }
type gnomadConstraintResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type regionResolver struct{ *Resolver }
type transcriptResolver struct{ *Resolver }
